<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="_lib.html">
<link rel="import" href="info-text.html">

<dom-module id="app-shell">
    <template>
        <!-- build:css(.tmp/elements) ../styles/app.css -->
        <link rel="stylesheet" href="../styles/app.css">
        <!-- endbuild -->

        <template is="dom-if" if="[[ _modalOpen ]]">
            <div class="modal" on-tap="closeModal">
                <div class="modal-content">
                    <span class="modal-close">&times;</span>

                    <div class="modal-scroll">
                        <info-text></info-text>
                    </div>
                </div>
            </div>
        </template>

        <div class="menubar">
            <a href="#" class="icon-info" on-tap="openModal">Info</a>
            <h3>Die Top 30 Begriffe</h3>
        </div>

        <div class="cloud-container">
            <div class$="bubble_cloud party-[[ activeParty ]] [[ _visClass ]]" id="bubble_cloud1"
                 on-word-click="selectedWord"
                 on-party-click="selectedParty"
                 on-back-click="goBack"></div>
            <img src="../images/wdr_logo.svg" class="logo">
            <a href="data.html" class="data-link">Tabellen-Darstellung</a>
        </div>

        <div class$="content-wrapper party-[[ activeParty ]]">
            <div class="tab-wrapper">
                <div class="tab-bar">
                    <iron-selector attr-for-selected="data-select"
                                   selected="{{ activeParty }}"
                                   fallback-selection="all"
                                   class="clearfix">
                        <div class="tab party-all" data-select="all">Alle</div>
                        <template is="dom-repeat" items="[[ parties ]]">
                            <div class$="tab party-[[ item ]]" data-select="[[ item ]]">[[ getPartyName(item) ]]</div>
                        </template>
                    </iron-selector>
                </div>
                <span class="topline"></span>
            </div>
            <div class="text-wrapper">
                <h4>[[ _textHeadline ]]</h4>
                <template is="dom-repeat" items="[[ textContent ]]" as="col">
                    <div class="text-col">
                        <template is="dom-repeat" items="[[ col ]]" on-dom-change="doHighlighting">
                            <p></p>
                        </template>
                    </div>
                </template>
            </div>
        </div>
    </template>
</dom-module>

<script>
    const partyMap = {
        cdu: "CDU",
        spd: "SPD",
        gruene: "Grüne",
        fdp: "FDP",
        linke: "Linke",
        piraten: "Piraten",
        afd: "AFD"
    };

    class AppShell extends Polymer.GestureEventListeners(Polymer.Element) {
        static get is() {
            return 'app-shell';
        }

        static get properties() {
            return {
                parties: {
                    type: Array,
                    value: () => ['spd', 'cdu', 'gruene', 'fdp', 'piraten', 'linke', 'afd']
                },
                activeParty: {
                    type: String
                },
                activeWord: {
                    type: String,
                    value: () => null
                },
                partyMap: {
                    type: Object,
                    value: () => partyMap
                },
                textContent: {
                    type: Array,
                    value: () => []
                },
                _visClass: {
                    type: String,
                    computed: 'getVisClass(activeWord)'
                },
                _modalOpen: {
                    type: Boolean,
                    value: false
                },
                _textHeadline: {
                    type: String,
                    value: () => ""
                }
            };
        }

        static get observers() {
            return [
                'filterData(activeParty, activeWord)'
            ]
        }


        ready() {
            super.ready();

            this.data = [];
            this.texts = {};
            this._filteredParty = '';
            this._filteredWord = null;
        }

        connectedCallback() {
            super.connectedCallback();

            const elem = this.shadowRoot.querySelector('#bubble_cloud1');

            fetch('output/all.json')
                .then(res => res.json())
                .then(json => {
                    this.data = json.data;
                    this.cloud = BubbleCloud(partyMap)(elem, []);
                    this.filterData(this.activeParty, this.activeWord);
                });

            Promise.all(this.parties.map(party => fetch('output/'+party+'.txt')))
                .then(results => Promise.all(results.map(resp => resp.text())))
                .then(results => results.forEach((item, key) => {
                    this.texts[this.parties[key]] = item.split('\n');
                }));
        }

        prepareData(data) {
            const add = (this.activeWord !== null && !_.find(data, (d, key) => (d.id ? d.id-1 : key) === this.activeWord.id)) ?
                [Object.assign((this.activeParty === 'all') ?
                    this.data[this.activeWord.id] :
                    dataHelpers.transformForParty(this.activeParty)(this.data[this.activeWord.id]),
                { id: this.activeWord.id+1 })] : [];
            return data.concat(add).map(dataHelpers.prepareData);
        }

        filterData(party, word) {
            if(!party || !this.cloud) {
                return;
            }

            const wordCountBubbles = 30;

            if(party !== this._filteredParty) {
                this._bubbleData = dataHelpers.bubbleData(this.data, party);
                this.cloud.updateData(this.prepareData(this._bubbleData.slice(0,wordCountBubbles)));
                this._filteredParty = party;
            }

            if(word !== null) {
                if(party === 'all') {
                    this.cloud.createPartyBubbles(this.prepareData([])[0]); // will return only the selected word
                } else {
                    this.cloud.destroyPartyBubbles();
                }
            }

            const wordCount = 20;
            const wordsForAll = Math.round(wordCount / 2);
            const wordsPerParty = Math.round(wordCount / 4);

            const baseData = (!word) ?
                ((party === 'all') ?
                    this._bubbleData
                        .slice(0, wordCountBubbles)
                        .sort(() => Math.random()*2-1)
                        .slice(0, wordsForAll)
                        .reduce(
                            (list, word) => list.concat(_.map(word.segments,
                                (val, party) => Object.assign(
                                    val.occurence[Math.floor(Math.random() * val.occurence.length)],
                                    { party: party }
                                )
                            )),
                        []) :
                    this._bubbleData
                        .slice(0, wordCountBubbles)
                        .sort(() => Math.random()*2-1)
                        .slice(0,wordCount)
                        .map(
                            word => word.occurence[Math.floor(Math.random() * word.occurence.length)]
                        )
                ) :
                ((party === 'all') ?
                    this.parties.reduce((sum, party) => sum.concat(
                        (!(party in this.data[word.id].segments)) ? [] :
                        Array.apply(null, Array(wordsPerParty))
                            .map(() => Math.round(Math.random() * (this.data[word.id].segments[party].occurence.length-1)))
                            .map(i => Object.assign(this.data[word.id].segments[party].occurence[i], { party: party }))
                    ), []) :
                    (party in this.data[word.id].segments) ?
                        this.data[word.id].segments[party].occurence
                            .sort(() => Math.random()*2-1)
                            .slice(0, wordCount) :
                        []
                );

            const numCols = Math.min(Math.floor(window.innerWidth / 320), 3);
            this.textContent = _.chunk(baseData.map(word => {
                const textParty = (party === 'all') ? word.party : party;
                return this.limitText(this.texts[textParty][word.paragraph_index], word.position, word.party);
            }), Math.floor(baseData.length / numCols)).reduce((sum, val, key) => {
                if(key >= numCols) {
                    sum[key-numCols].concat(val);
                } else {
                    sum.push(val);
                }
                return sum;
            }, []);

            // set headline
            this._textHeadline =
                (party === 'all') ? (
                    (word === null) ?
                        "Zufällig gewählte Stellen für Top-30-Wörter" :
                        `Zufällig gewählte Stellen für „${word.name}“`
                ) : (
                    (word === null) ?
                        `Zufällig gewählte Stellen für Top-30-Wörter im ${partyMap[party]}-Wahlprogramm` :
                        `Zufällig gewählte Stellen für „${word.name}“ im ${partyMap[party]}-Wahlprogramm`
                );

            this._filteredWord = word;
        }

        limitText(text, pos, party) {
            let start = text.lastIndexOf(". ", pos);
            start = start === -1 ? 0 : start+2;
            let end = text.indexOf(". ", pos);
            end = end === -1 ? text.length : end+1;
            let wordEnd = text.indexOf(' ', pos);
            wordEnd = (wordEnd === -1 ? text.length : wordEnd) - pos;
            return {
                text: text.substring(start, end),
                pos: pos-start,
                wordlen: wordEnd,
                party: party
            };
        }

        getPartyName(slug) {
            return partyMap[slug];
        }

        doHighlighting(ev) {
            const col = ev.target.parentElement;
            col.querySelectorAll('p').forEach(elem => {
                const item = ev.target.modelForElement(elem).item;
                elem.textContent = "";
                elem.appendChild(document.createTextNode(item.text.substr(0, item.pos)));
                const highlight = document.createElement('span');
                highlight.textContent = item.text.substr(item.pos, item.wordlen);
                highlight.className = 'highlight';
                elem.appendChild(highlight);
                elem.appendChild(document.createTextNode(item.text.substr(item.pos + item.wordlen)));
                elem.className = item.party ? 'party-' + item.party : '';
            });
        }

        selectedWord(ev) {
            this.activeWord = {
                name: ev.detail.name,
                id: ev.detail.id-1
            };
            this.cloud.selectNode(ev.detail);
        }

        selectedParty(ev) {
            this.activeParty = ev.detail.id;
        }

        goBack() {
            this.activeWord = null;
            this.cloud.selectNode(null);
            this.cloud.destroyPartyBubbles();
        }

        getVisClass(word) {
            return word !== null ? 'selection-active' : '';
        }

        openModal(ev) {
            this._modalOpen = true;
            ev.preventDefault();
        }

        closeModal(ev) {
            if(ev.target == this.root.querySelector('.modal') ||
                ev.target == this.root.querySelector('.modal-close')) {
                this._modalOpen = false;
            }
        }
    }

    customElements.define(AppShell.is, AppShell);

    // more button in teaser
    (function() {
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelector('.info-modal-link').addEventListener('click', ev => {
                document.querySelector('app-shell').openModal(ev);
            });
        });
    })();
</script>